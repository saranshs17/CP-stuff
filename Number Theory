  // Modular arithematic formulae
  1. (a+b) % M =((a % M ) + (b % M)) % M
  2. (a*b) % M =((a % M ) * (b % M)) % M
  3. (a-b) % M =((a % M ) - (b % M) + M) % M
  4. (a/b) % M =((a % M ) * (b^-1 % M)) % M  // b^-1 multiplicative inverse ,calculate using binary exponentiation
  example. ll fact=1;
            loop(n){
                fact = (fact * i) % M;
            } cout<< fact;
// significance 10^9+7 : 1. is very close to INT_MAX means final ans can be stored in int ll not needed4
                         2. prime number so Multiplicative inverse can bre found easily
//Set, Unset, Count Bits

//Set bit  -->check at k
              if((n & (1<<k)) != 0){
            	cout<<"set bit"<<ln;
              }else{
            	cout<<"not set bit"<<ln;
               }
          -->  // bit set at i 
                printBinary(n | (1<<i));
//Bit Unset 
                // bit unset at j using tilda~
                printBinary( n & ~(1<<j));
                // toggle using xor (0->1 and 1->0) at s
                printBinary(n^(1<<s));
// counting bit set
                //1.
                int ct=0;
                 for(int i=31;i>=0;i--){
               	if((n & (1<<i)) != 0){
            		ct++;
              	}
                }
                cout<<ct<<ln;
                //2. built in funtion for integer value
                cout<<__builtin_popcount(1LL<<35)<<ln; // output will be 0 or runtime error as integer cant store long long 
                //3. built in function for long long value
                cout<<__builtin_popcountll(1LL<<35)<<ln; //output 1
// Bit Manipulation Tricks
                --> // checking odd/even
                    if(n&1) odd; //taking and of 1 with 0th bit so if if is 1 then odd else 0 is for even
                    else even;
                --> // multiplying dividing by 2 
                    cout<< n>>2; // divide by 2
                    cout<< n<<2; // multiply by 2
                --> // lower case to uppercase conversion vice versa
                    char A = 'A'
                    char a = A | (1<<5) // to rem: as a has more ascii value so bigger binary number  so it will(all lower case alphabets) have bit set (or 1) at 5th index
                    cout<< a; // prints a 
                    cout<< char(a&(~(1<<5))); // prints A
-->Note: we can use character instead of '_'(underscore) or ' '(space). 
                    ex : 
                    cour<<char('A'|' '); // prints a
                    cout<<char('a'&'_'); // prints A
// MSB(Most significant bit) --> rightmost set bit and LSB(Least Significant Bit)--> set bit
                    ex:00000100001 , so MSB=5th bit and LSB=0th bit
                 -->implementation
                    int num;
                  	int LSB,MSB;
                  	cin>>num>>LSB>>MSB;
                  	printBinary(num);
                  	printBinary(num&(~((1<<(LSB+1))-1))); //prints till LSB
                    printBinary(num&(((1<<(MSB+1))-1))); //prints till MSB
                    ex:00000111011  // num = 59
                       00000100000  // LSB = 4
                       00000001011  // MSB = 3 
                    // means MSB+LSB = num

// check power of 2 
                    int n;
                    cin>>n;
                  	if(n & (n-1)){   // 00001 & 10000 = 00000 as n = 1 
	                  	cout<<" not power of two"; 
	                  }else{
	                  	cout<<"power of two";
	                  }
// swapping number using XOR 
		    int a,b; cin>>a>>b;
		    a=a^b;
		    b=b^a;
                    a=a^b;
// XOR of a ^ a = 0 property 
                    ex: find number of odd count from an array containing n numbers and n-1 are in even count(duplicates)
		    solution: O(N) TC and O(1) SC 
			    -->int res=a[0]; 
			       for(int i=1;i<n;++i) res^=a[i];
			       cout<<res;
